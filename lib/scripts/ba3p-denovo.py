# MultiSampleActor

import csv
import os.path
from SampleCollection import SampleCollection

def message(string, *args):
    # Write `string' to standard error. `args' are 
    # inserted into `string' with format.
    sys.stderr.write(string.format(*args))
    sys.stderr.write("\n")

def dump(self):
    self.message("Title: {}", self.title)
    self.message("Reference: {}", self.reference)
    self.sc.showSamples()

### Script code starts here

## Initialization

ACT.loadConfiguration(ACT.Arguments[0])
print ACT.Conf
SC = SampleCollection(ACT.Conf)
ACT.sc = SC

ACT.title = ACT.getConf("title")
ACT.reference = ACT.checkPath(ACT.getConf("reference"))
ACT.setSteps(ACT.getConf("steps"))

## Check that all fastq files exist
for r in SC.readsets:
    ACT.checkPath(r['left'])
    ACT.checkPath(r['right'])

dump(ACT)

# Script definition 

ACT.script(ACT.title, "BA3P - De-novo Assembly", "BA3P")
ACT.begin(timestamp=False)

ACT.scene(1, "General configuration")
ACT.reportf("""Experiment name: <b>{}</b><br>""".format(ACT.title))
ACT.reportf("Samples and input files:<br>")
ACT.table([ [r['name'], r['left'], r['right'] ] for r in SC.readsets],
          header=["Sample", "Left reads", "Right reads"],
          align="HLL")

#
# Before we start, check if reference file is indexed
#

fai = ACT.reference + ".fai" 
refdict = ACT.setFileExt(ACT.reference, ".dict")

if ACT.missingOrStale(fai, ACT.reference):
    print "Reference index {} does not exist or is out of date, creating it.".format(fai)
    ACT.shell("module load samtools; samtools faidx {}", ACT.reference)

if ACT.missingOrStale(refdict, ACT.reference):
    print "Reference dictionary {} does not exist, creating it.".format(refdict)
    ACT.submit("picard.qsub CreateSequenceDictionary R={} O={}".format(ACT.reference, refdict), done="dict.done")
    ACT.wait("dict.done")

# Ensure we don't have old .done files lying around
ACT.shell("rm -f *.done")

#
# First of all run FastQC and sickle on fastq files
#

## Call trimmomatic on each pair, and then fastqc on the trimmed files

if ACT.step("sickle") and ACT.step("trimm"):
    print "Error: please specify only one of 'sickle' and 'trimm'"
    sys.exit()

if ACT.step("sickle"):
    ACT.runSickle(fastqc=ACT.step("fastqc"))
elif ACT.step("trimm"):
    ACT.runTrimmomatic(fastqc=ACT.step("fastqc"))
else:
    ACT.runTrimmomatic(run=False)

## Run spades on each sample

nspades = 0
for smp in SC.samples:
    outdir = smp['name'] + ".spades/"
    smp['spadesdir'] = outdir
    smprs = smp['readsets'][0]
    ACT.mkdir(outdir)
    if ACT.step("spades"):
        ACT.submit("spades.qsub {} {} {}".format(outdir, smprs['left'], smprs['right']), done="spades.@.done")
        nspades = nspades + 1
ACT.wait(("spades.@.done", nspades))

## Create contigs directory and copy fasta files into it

ACT.mkdir("Contigs")
ACT.shell("touch dummymap")
for smp in SC.samples:
    infasta = smp['spadesdir'] + "contigs.fasta"
    outfasta = "Contigs/" + smp['name'] + ".spades.fasta"
    #ACT.shell("cp {} Contigs/{}".format(infasta, outfasta))
    ACT.shell("module load dibig_tools; fastools -map -mapfile-in dummymap -in {} -out {} -if-missing counter -prefix {}_", infasta, outfasta, smp['name'])

## Run Mauve contig orderer

if ACT.step("mauve"):
    ACT.submit("mauve-contig-mover.qsub {}".format(ACT.reference), done="mauve.done")
    ACT.wait("mauve.done")

## Collect assembled sequences generated by mauve

ACT.mkdir("Alignments")
for smp in SC.samples:
    base = "Ordered/" + smp['spadesdir']
    alns = os.listdir(base)
    maxa = [0, '']
    for a in alns:
        if a[0:9] == 'alignment':
            i = int(a[9:])
            if i > maxa[0]:
                maxa = [i, a]
    ACT.shell("cp {}/{}/{}.spades.fasta Alignments/".format(base, maxa[1], smp['name']))

if ACT.step("progmauve"):
    os.chdir("Alignments")
    ACT.submit("progressive-mauve.qsub denovo-final denovo-final", done="../progr.done")
    os.chdir("..")
    ACT.wait("progr.done")
    
